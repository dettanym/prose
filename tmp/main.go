package main

import (
	"context"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/jaegertracing/jaeger/model"
	"github.com/jaegertracing/jaeger/proto-gen/api_v2"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

// Run `docker compose up -d` to start services before this program
func main() {
	// setup grpc client and query jaeger
	grpcCC, err := grpc.Dial(
		"192.168.49.22:16685",
		grpc.WithTransportCredentials(insecure.NewCredentials()),
	)
	if err != nil {
		fmt.Printf("error dialing grpc server:\n%v\n", err)
		return
	}

	defer func() {
		err := grpcCC.Close()
		if err != nil {
			fmt.Printf("error closing grpc client connection:\n%v\n", err)
		}
	}()

	// for possible operations see:
	// https://github.com/jaegertracing/jaeger-idl/blob/main/proto/api_v2/query.proto
	// https://github.com/jaegertracing/jaeger/blob/main/proto-gen/api_v2/query.pb.go
	jaegerQueryClient := api_v2.NewQueryServiceClient(grpcCC)

	services, err := jaegerQueryClient.GetServices(
		context.Background(),
		&api_v2.GetServicesRequest{},
	)

	if err != nil {
		fmt.Printf("error loading services:\n%v\n", err)
		return
	} else {
		fmt.Printf("loaded services:\n%v\n", services.Services)
	}

	findTracesClient, err := jaegerQueryClient.FindTraces(
		context.Background(),
		&api_v2.FindTracesRequest{
			Query: &api_v2.TraceQueryParameters{
				// ServiceName seems to be required
				ServiceName: "golang-filter",
				//OperationName: "SQL SELECT",
				//Tags: map[string]string{
				//	"span.kind": "client",
				//},
				// Treated as num_traces, the number of traces to return in the response
				// SearchDepth: 3,
				StartTimeMin: time.Now().Add(-time.Hour),
				StartTimeMax: time.Now(),
			},
		},
	)
	// TODO: Convert map value to []Spans
	//  and then to map[SpanID]Span
	traceIDToSpansMap := map[model.TraceID]api_v2.SpansResponseChunk{}
	numberOfResponseChunksFound := 0
	numberOfSpansFound := 0
	for {
		spansResponse, err := findTracesClient.Recv()
		if err != nil { // probably got an EOF
			if numberOfResponseChunksFound == 0 {
				fmt.Printf("error finding traces:\n%v\n", err)
			}
			break
		}
		// found a spans response chunk
		numberOfResponseChunksFound += 1

		for _, span := range spansResponse.GetSpans() {
			numberOfSpansFound += 1
			spansResponseChunkForTrace, sameTraceExistsBefore := traceIDToSpansMap[span.TraceID]
			if sameTraceExistsBefore {
				otherSpansInSameTrace := spansResponseChunkForTrace.GetSpans()
				otherSpansInSameTrace = append(otherSpansInSameTrace, span)
				traceIDToSpansMap[span.TraceID] = api_v2.SpansResponseChunk{
					Spans: otherSpansInSameTrace,
				}
			} else {
				traceIDToSpansMap[span.TraceID] = *spansResponse
			}

			fmt.Printf("--> Span Operation name: %s\n", span.OperationName)
			fmt.Printf("Span details: trace id %s, span id: %s, parent span id: %s,\n", span.TraceID, span.SpanID, span.ParentSpanID())
			fmt.Printf("Span start time: %s, duration: %s, references:%s\n", span.GetStartTime(), span.GetDuration(), span.GetReferences())

			printTags(span)
		}
	}
	fmt.Printf("found %d spans across %d traces\n", numberOfSpansFound, len(traceIDToSpansMap))
}

func queryHotrod() {
	var err error

	// run some workloads so traces are created
	_, err = http.Get("http://localhost:8080/dispatch?customer=123")
	if err != nil {
		fmt.Printf("error querying hotrod app:\n%v\n", err)
		return
	}

	_, err = http.Get("http://localhost:8080/dispatch?customer=392")
	if err != nil {
		fmt.Printf("error querying hotrod app:\n%v\n", err)
		return
	}

	_, err = http.Get("http://localhost:8080/dispatch?customer=731")
	if err != nil {
		fmt.Printf("error querying hotrod app:\n%v\n", err)
		return
	}

	_, err = http.Get("http://localhost:8080/dispatch?customer=567")
	if err != nil {
		fmt.Printf("error querying hotrod app:\n%v\n", err)
		return
	}
}

func printTags(s model.Span) {
	var tagsForProcess model.KeyValues
	tagsForProcess = s.GetProcess().GetTags()
	tagsForProcess.Sort()
	for _, kv := range tagsForProcess {
		if strings.Contains(kv.GetKey(), "ip") {
			// TODO: This value is parsed as a negative integer. Need to get an ip address instead.
			fmt.Printf("Process tag. %s: (%s) %s\n", kv.GetKey(), kv.VType, kv.VInt64)
		}
	}

	// check if the span is generated by our filter crudely using the span name
	if strings.Contains(s.OperationName, "encode") ||
		strings.Contains(s.OperationName, "decode") {
		// scan through our attributes for the direction and the service name
		fmt.Printf("Golang filter's span\n")
	}

	var tags model.KeyValues
	tags = s.GetTags()
	tags.Sort()
	for _, kv := range tags {
		if strings.Contains(kv.GetKey(), "direction") ||
			strings.Contains(kv.GetKey(), "svcName") {
			fmt.Printf("Golang filter with key %s value %s\n", kv.GetKey(), kv.VStr)
		} else if strings.Contains(kv.GetKey(), "component") &&
			strings.Contains(kv.Value().(string), "proxy") {
			fmt.Printf("Envoy proxy\n")
		} else if strings.Contains(kv.GetKey(), "x-request-id") ||
			strings.Contains(kv.GetKey(), "address") ||
			strings.Contains(kv.GetKey(), "url") ||
			strings.Contains(kv.GetKey(), "cluster") {
			fmt.Printf("Envoy proxy with key %s: %s\n", kv.GetKey(), kv.VStr)
		}
	}
	// fmt.Printf("found an attribute with key %s value %s\n", kv.GetKey(), kv.Value.GetStringValue())

}

func parseSpan(spanID model.SpanID, spanStore map[model.SpanID]model.Span) error {
	span, ok := spanStore[spanID]

	if !ok {
		return fmt.Errorf("could not find span with id %s\n", spanID)
	}

	// get whether the golang filter is inbound / outbound and encode / decode
	var tags model.KeyValues
	tags = span.GetTags()
	inboundOutbound, ok := tags.FindByKey("direction")
	if !ok {
		return fmt.Errorf("could not determine the direction (inbound or outbound) of golangfilter span%s\n", inboundOutbound)
	}
	isInbound := strings.Contains(inboundOutbound.VStr, "INBOUND")
	isDecode := strings.Contains(span.GetOperationName(), "decode")

	// get the parent of the golang-filter span
	parentSpanID := span.ParentSpanID()
	parentSpan, ok := spanStore[parentSpanID]
	if !ok { // this is unusual since a golang-filter service always has a parent span: namely, the Envoy SP
		return fmt.Errorf("could not find parent span with id %s\n", parentSpan)
	}

	// validate that the parent is an envoy SP by checking for the component:proxy span tag
	var parentTags model.KeyValues
	parentTags = parentSpan.GetTags()
	value, ok := parentTags.FindByKey("component")
	parentIsEnvoyProxy := ok && value.VStr == "proxy"
	if !parentIsEnvoyProxy {
		return fmt.Errorf("parent of a Golangfilter span does not have a tag component:proxy and so is probably not an Envoy Proxy")
	}
	parentServiceName := parentSpan.GetProcess().GetServiceName()
	parentOperationName := parentSpan.GetOperationName()
	fmt.Printf("%s %s\n", parentServiceName, parentOperationName)

	// In all cases add PII types in tags in *own* span to the profile of the parent (which can be the caller or the callee)
	if isInbound {
		// parent is the callee SP
		// get the caller by traversing up the call stack
		callerSpanID, err := findAnAncestorCaller(parentSpan.SpanID, spanStore)
		if err != nil {
			return fmt.Errorf("could not find the caller of this span %s\n", parentSpanID)
		}
		callerServiceName := callerSpanID.GetProcess().GetServiceName()
		callerOperationName := callerSpanID.GetOperationName()
		fmt.Printf("%s %s\n", callerServiceName, callerOperationName)

		if isDecode {
			// PII types are sent in a direct request to the parent (callee)
			// Could lead to a direct purpose of use violation
		} else { // Encode case
			// Ignore for now. Handled in outbound encode case
			// PII types are returned in a response by the parent (callee)
		}
	} else { // OUTBOUND sidecar
		// parent is the caller SP
		// get the callee by traversing down the call stack
		// afaict the Span object doesn't store references to own children so can't go down the call stack
		// maybe whenever you find an ancestor caller using the inbound SP, mark it as such?
		calleeSpanID, err := findAnAncestorCaller(parentSpan.SpanID, spanStore)
		if err != nil {
			return fmt.Errorf("could not find the callee of this span %s\n", parentSpanID)
		}
		calleeServiceName := calleeSpanID.GetProcess().GetServiceName()
		calleeOperationName := calleeSpanID.GetOperationName()
		fmt.Printf("%s %s\n", calleeServiceName, calleeOperationName)
		if isDecode {
			// PII types are sent in a request to a third party
			// can cause a data sharing violation
		} else { // Encode case
			// PII types are sent in a response from either a third party or another service
			// we ignore the first case for now
			// in the second case, can cause an indirect purpose of use violation
		}
	}
	return nil
}

func findAnAncestorCaller(spanID model.SpanID, spansStore map[model.SpanID]model.Span) (model.Span, error) {
	// TODO Implement this findAnAncestorCaller
	// go access the parent using the span.ParentSpanID(). Look it up in the spansStore. If the span's operation name includes the words "router * egress" then go to its parent
	// e.g. for service2's checkstock span
	// the parent would be the service1's "router service2 egress" span, which we know has been inserted by envoy
	// so we skip it and get to its parent, ie service1's checkStock and return it
	return spansStore[spanID], nil
}
