package main

import (
	"context"
	"fmt"
	"github.com/jaegertracing/jaeger/model"
	"github.com/jaegertracing/jaeger/proto-gen/api_v2"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"strings"
)

// Run `docker compose up -d` to start services before this program
func main() {
	//var err error
	//
	//// run some workloads so traces are created
	//_, err = http.Get("http://localhost:8080/dispatch?customer=123")
	//if err != nil {
	//	fmt.Printf("error querying hotrod app:\n%v\n", err)
	//	return
	//}
	//
	//_, err = http.Get("http://localhost:8080/dispatch?customer=392")
	//if err != nil {
	//	fmt.Printf("error querying hotrod app:\n%v\n", err)
	//	return
	//}
	//
	//_, err = http.Get("http://localhost:8080/dispatch?customer=731")
	//if err != nil {
	//	fmt.Printf("error querying hotrod app:\n%v\n", err)
	//	return
	//}
	//
	//_, err = http.Get("http://localhost:8080/dispatch?customer=567")
	//if err != nil {
	//	fmt.Printf("error querying hotrod app:\n%v\n", err)
	//	return
	//}

	// setup grpc client and query jaeger

	grpcCC, err := grpc.Dial(
		"localhost:16685",
		grpc.WithTransportCredentials(insecure.NewCredentials()),
	)
	if err != nil {
		fmt.Printf("error dialing grpc server:\n%v\n", err)
		return
	}

	defer func() {
		err := grpcCC.Close()
		if err != nil {
			fmt.Printf("error closing grpc client connection:\n%v\n", err)
		}
	}()

	// for possible operations see:
	// https://github.com/jaegertracing/jaeger-idl/blob/main/proto/api_v2/query.proto
	// https://github.com/jaegertracing/jaeger/blob/main/proto-gen/api_v2/query.pb.go
	jaegerQueryClient := api_v2.NewQueryServiceClient(grpcCC)

	services, err := jaegerQueryClient.GetServices(
		context.Background(),
		&api_v2.GetServicesRequest{},
	)

	if err != nil {
		fmt.Printf("error loading services:\n%v\n", err)
		return
	} else {
		fmt.Printf("loaded services:\n%v\n", services.Services)
	}

	findTracesClient, err := jaegerQueryClient.FindTraces(
		context.Background(),
		&api_v2.FindTracesRequest{
			Query: &api_v2.TraceQueryParameters{
				// ServiceName seems to be required
				ServiceName: "golang-filter",
				//OperationName: "SQL SELECT",
				//Tags: map[string]string{
				//	"span.kind": "client",
				//},
				// Treated as num_traces, the number of traces to return in the response
				// SearchDepth: 3,
			},
		},
	)
	if err != nil {
		fmt.Printf("error finding traces:\n%v\n", err)
		return
	}

	spansResponse, err := findTracesClient.Recv()
	if err != nil {
		fmt.Printf("error receiving the response:\n%v\n", err)
		return
	}

	spans := spansResponse.GetSpans()

	if len(spans) == 0 {
		fmt.Printf("successfully queried. no spans found")
	} else {
		fmt.Printf("successfully queried. found %d *resource* spans\n", len(spans))
	}

	var traceids []model.TraceID
	traceidsSeen := map[model.TraceID]bool{}

	for _, s := range spans {
		printTags(s)

		if !traceidsSeen[s.TraceID] {
			traceids = append(traceids, s.TraceID)
		}
		traceidsSeen[s.TraceID] = true
	}

	fmt.Printf("\nfound %d relevant traces\n", len(traceids))

	fmt.Printf("selected 0th trace with name %s\n", traceids[0].String())

}

func printTags(s model.Span) {
	var tagsForProcess model.KeyValues
	tagsForProcess = s.GetProcess().GetTags()
	tagsForProcess.Sort()
	for _, kv := range tagsForProcess {
		if strings.Contains(kv.GetKey(), "ip") {
			// TODO: This value is parsed as a negative integer. Need to get an ip address instead.
			fmt.Printf("Process tag. %s: (%s) %s\n", kv.GetKey(), kv.VType, kv.VInt64)
		}
	}

	// check if the span is generated by our filter crudely using the span name
	if strings.Contains(s.OperationName, "encode") ||
		strings.Contains(s.OperationName, "decode") {
		// scan through our attributes for the direction and the service name
		fmt.Printf("Golang filter's span\n")
	}

	var tags model.KeyValues
	tags = s.GetTags()
	tags.Sort()
	for _, kv := range tags {
		if strings.Contains(kv.GetKey(), "direction") ||
			strings.Contains(kv.GetKey(), "svcName") {
			fmt.Printf("Golang filter with key %s value %s\n", kv.GetKey(), kv.VStr)
		} else if strings.Contains(kv.GetKey(), "component") &&
			strings.Contains(kv.Value().(string), "proxy") {
			fmt.Printf("Envoy proxy\n")
		} else if strings.Contains(kv.GetKey(), "x-request-id") ||
			strings.Contains(kv.GetKey(), "address") ||
			strings.Contains(kv.GetKey(), "url") ||
			strings.Contains(kv.GetKey(), "cluster") {
			fmt.Printf("Envoy proxy with key %s: %s\n", kv.GetKey(), kv.VStr)
		}
	}
	// fmt.Printf("found an attribute with key %s value %s\n", kv.GetKey(), kv.Value.GetStringValue())

}
